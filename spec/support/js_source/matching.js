// Generated by CoffeeScript 2.2.2
var SEQUENCES, build_dict_matcher, build_ranked_dict, check_date, date_match, date_rx_year_prefix, date_rx_year_suffix, date_sep_match, date_without_sep_match, dictionary_match, digits_match, digits_rx, empty, enumerate_l33t_subs, extend, findall, l33t_match, l33t_table, omnimatch, relevent_l33t_subtable, repeat, repeat_match, sequence_match, spatial_match, spatial_match_helper, translate, year_match, year_rx;

empty = function(obj) {
  var k;
  return ((function() {
    var results;
    results = [];
    for (k in obj) {
      results.push(k);
    }
    return results;
  })()).length === 0;
};

extend = function(lst, lst2) {
  return lst.push.apply(lst, lst2);
};

translate = function(string, chr_map) {
  var chr;
  return ((function() {
    var l, len1, ref, results;
    ref = string.split('');
    results = [];
    for (l = 0, len1 = ref.length; l < len1; l++) {
      chr = ref[l];
      results.push(chr_map[chr] || chr);
    }
    return results;
  })()).join('');
};

// ------------------------------------------------------------------------------
// omnimatch -- combine everything ----------------------------------------------
// ------------------------------------------------------------------------------
omnimatch = function(password) {
  var l, len1, matcher, matches;
  matches = [];
  for (l = 0, len1 = MATCHERS.length; l < len1; l++) {
    matcher = MATCHERS[l];
    extend(matches, matcher(password));
  }
  return matches.sort(function(match1, match2) {
    return (match1.i - match2.i) || (match1.j - match2.j);
  });
};

//-------------------------------------------------------------------------------
// dictionary match (common passwords, english, last names, etc) ----------------
//-------------------------------------------------------------------------------
dictionary_match = function(password, ranked_dict) {
  var i, j, l, len, m, password_lower, rank, ref, ref1, ref2, result, word;
  result = [];
  len = password.length;
  password_lower = password.toLowerCase();
  for (i = l = 0, ref = len; (0 <= ref ? l < ref : l > ref); i = 0 <= ref ? ++l : --l) {
    for (j = m = ref1 = i, ref2 = len; (ref1 <= ref2 ? m < ref2 : m > ref2); j = ref1 <= ref2 ? ++m : --m) {
      if (password_lower.slice(i, +j + 1 || 9e9) in ranked_dict) {
        word = password_lower.slice(i, +j + 1 || 9e9);
        rank = ranked_dict[word];
        result.push({
          pattern: 'dictionary',
          i: i,
          j: j,
          token: password.slice(i, +j + 1 || 9e9),
          matched_word: word,
          rank: rank
        });
      }
    }
  }
  return result;
};

build_ranked_dict = function(unranked_list) {
  var i, l, len1, result, word;
  result = {};
  i = 1; // rank starts at 1, not 0
  for (l = 0, len1 = unranked_list.length; l < len1; l++) {
    word = unranked_list[l];
    result[word] = i;
    i += 1;
  }
  return result;
};

build_dict_matcher = function(dict_name, ranked_dict) {
  return function(password) {
    var l, len1, match, matches;
    matches = dictionary_match(password, ranked_dict);
    for (l = 0, len1 = matches.length; l < len1; l++) {
      match = matches[l];
      match.dictionary_name = dict_name;
    }
    return matches;
  };
};

//-------------------------------------------------------------------------------
// dictionary match with common l33t substitutions ------------------------------
//-------------------------------------------------------------------------------
l33t_table = {
  a: ['4', '@'],
  b: ['8'],
  c: ['(', '{', '[', '<'],
  e: ['3'],
  g: ['6', '9'],
  i: ['1', '!', '|'],
  l: ['1', '|', '7'],
  o: ['0'],
  s: ['$', '5'],
  t: ['+', '7'],
  x: ['%'],
  z: ['2']
};

// makes a pruned copy of l33t_table that only includes password's possible substitutions
relevent_l33t_subtable = function(password) {
  var chr, filtered, l, len1, letter, password_chars, ref, relevent_subs, sub, subs;
  password_chars = {};
  ref = password.split('');
  for (l = 0, len1 = ref.length; l < len1; l++) {
    chr = ref[l];
    password_chars[chr] = true;
  }
  filtered = {};
  for (letter in l33t_table) {
    subs = l33t_table[letter];
    relevent_subs = (function() {
      var len2, m, results;
      results = [];
      for (m = 0, len2 = subs.length; m < len2; m++) {
        sub = subs[m];
        if (sub in password_chars) {
          results.push(sub);
        }
      }
      return results;
    })();
    if (relevent_subs.length > 0) {
      filtered[letter] = relevent_subs;
    }
  }
  return filtered;
};

// returns the list of possible 1337 replacement dictionaries for a given password
enumerate_l33t_subs = function(table) {
  var chr, dedup, helper, k, keys, l, l33t_chr, len1, len2, m, sub, sub_dict, sub_dicts, subs;
  keys = (function() {
    var results;
    results = [];
    for (k in table) {
      results.push(k);
    }
    return results;
  })();
  subs = [[]];
  dedup = function(subs) {
    var assoc, deduped, l, label, len1, members, sub, v;
    deduped = [];
    members = {};
    for (l = 0, len1 = subs.length; l < len1; l++) {
      sub = subs[l];
      assoc = (function() {
        var len2, m, results;
        results = [];
        for (v = m = 0, len2 = sub.length; m < len2; v = ++m) {
          k = sub[v];
          results.push([k, v]);
        }
        return results;
      })();
      assoc.sort();
      label = ((function() {
        var len2, m, results;
        results = [];
        for (v = m = 0, len2 = assoc.length; m < len2; v = ++m) {
          k = assoc[v];
          results.push(k + ',' + v);
        }
        return results;
      })()).join('-');
      if (!(label in members)) {
        members[label] = true;
        deduped.push(sub);
      }
    }
    return deduped;
  };
  helper = function(keys) {
    var dup_l33t_index, first_key, i, l, l33t_chr, len1, len2, m, next_subs, o, ref, ref1, rest_keys, sub, sub_alternative, sub_extension;
    if (!keys.length) {
      return;
    }
    first_key = keys[0];
    rest_keys = keys.slice(1);
    next_subs = [];
    ref = table[first_key];
    for (l = 0, len1 = ref.length; l < len1; l++) {
      l33t_chr = ref[l];
      for (m = 0, len2 = subs.length; m < len2; m++) {
        sub = subs[m];
        dup_l33t_index = -1;
        for (i = o = 0, ref1 = sub.length; (0 <= ref1 ? o < ref1 : o > ref1); i = 0 <= ref1 ? ++o : --o) {
          if (sub[i][0] === l33t_chr) {
            dup_l33t_index = i;
            break;
          }
        }
        if (dup_l33t_index === -1) {
          sub_extension = sub.concat([[l33t_chr, first_key]]);
          next_subs.push(sub_extension);
        } else {
          sub_alternative = sub.slice(0);
          sub_alternative.splice(dup_l33t_index, 1);
          sub_alternative.push([l33t_chr, first_key]);
          next_subs.push(sub);
          next_subs.push(sub_alternative);
        }
      }
    }
    subs = dedup(next_subs);
    return helper(rest_keys);
  };
  helper(keys);
  sub_dicts = []; // convert from assoc lists to dicts
  for (l = 0, len1 = subs.length; l < len1; l++) {
    sub = subs[l];
    sub_dict = {};
    for (m = 0, len2 = sub.length; m < len2; m++) {
      [l33t_chr, chr] = sub[m];
      sub_dict[l33t_chr] = chr;
    }
    sub_dicts.push(sub_dict);
  }
  return sub_dicts;
};

l33t_match = function(password) {
  var chr, k, l, len1, len2, len3, m, match, match_sub, matcher, matches, o, ref, ref1, sub, subbed_chr, subbed_password, token, v;
  matches = [];
  ref = enumerate_l33t_subs(relevent_l33t_subtable(password));
  for (l = 0, len1 = ref.length; l < len1; l++) {
    sub = ref[l];
    if (empty(sub)) { // corner case: password has no relevent subs.
      break;
    }
    for (m = 0, len2 = DICTIONARY_MATCHERS.length; m < len2; m++) {
      matcher = DICTIONARY_MATCHERS[m];
      subbed_password = translate(password, sub);
      ref1 = matcher(subbed_password);
      for (o = 0, len3 = ref1.length; o < len3; o++) {
        match = ref1[o];
        token = password.slice(match.i, +match.j + 1 || 9e9);
        if (token.toLowerCase() === match.matched_word) {
          continue; // only return the matches that contain an actual substitution
        }
        match_sub = {}; // subset of mappings in sub that are in use for this match
        for (subbed_chr in sub) {
          chr = sub[subbed_chr];
          if (token.indexOf(subbed_chr) !== -1) {
            match_sub[subbed_chr] = chr;
          }
        }
        match.l33t = true;
        match.token = token;
        match.sub = match_sub;
        match.sub_display = ((function() {
          var results;
          results = [];
          for (k in match_sub) {
            v = match_sub[k];
            results.push(`${k} -> ${v}`);
          }
          return results;
        })()).join(', ');
        matches.push(match);
      }
    }
  }
  return matches;
};

// ------------------------------------------------------------------------------
// spatial match (qwerty/dvorak/keypad) -----------------------------------------
// ------------------------------------------------------------------------------
spatial_match = function(password) {
  var graph, graph_name, matches;
  matches = [];
  for (graph_name in GRAPHS) {
    graph = GRAPHS[graph_name];
    extend(matches, spatial_match_helper(password, graph, graph_name));
  }
  return matches;
};

spatial_match_helper = function(password, graph, graph_name) {
  var adj, adjacents, cur_char, cur_direction, found, found_direction, i, j, l, last_direction, len1, prev_char, result, shifted_count, turns;
  result = [];
  i = 0;
  while (i < password.length - 1) {
    j = i + 1;
    last_direction = null;
    turns = 0;
    shifted_count = 0;
    while (true) {
      prev_char = password.charAt(j - 1);
      found = false;
      found_direction = -1;
      cur_direction = -1;
      adjacents = graph[prev_char] || [];
      // consider growing pattern by one character if j hasn't gone over the edge.
      if (j < password.length) {
        cur_char = password.charAt(j);
        for (l = 0, len1 = adjacents.length; l < len1; l++) {
          adj = adjacents[l];
          cur_direction += 1;
          if (adj && adj.indexOf(cur_char) !== -1) {
            found = true;
            found_direction = cur_direction;
            if (adj.indexOf(cur_char) === 1) {
              // index 1 in the adjacency means the key is shifted, 0 means unshifted: A vs a, % vs 5, etc.
              // for example, 'q' is adjacent to the entry '2@'. @ is shifted w/ index 1, 2 is unshifted.
              shifted_count += 1;
            }
            if (last_direction !== found_direction) {
              // adding a turn is correct even in the initial case when last_direction is null:
              // every spatial pattern starts with a turn.
              turns += 1;
              last_direction = found_direction;
            }
            break;
          }
        }
      }
      // if the current pattern continued, extend j and try to grow again
      if (found) {
        j += 1;
      } else {
        // otherwise push the pattern discovered so far, if any...
        if (j - i > 2) { // don't consider length 1 or 2 chains.
          result.push({
            pattern: 'spatial',
            i: i,
            j: j - 1,
            token: password.slice(i, j),
            graph: graph_name,
            turns: turns,
            shifted_count: shifted_count
          });
        }
        // ...and then start a new search for the rest of the password.
        i = j;
        break;
      }
    }
  }
  return result;
};

//-------------------------------------------------------------------------------
// repeats (aaa) and sequences (abcdef) -----------------------------------------
//-------------------------------------------------------------------------------
repeat_match = function(password) {
  var cur_char, i, j, prev_char, result;
  result = [];
  i = 0;
  while (i < password.length) {
    j = i + 1;
    while (true) {
      [prev_char, cur_char] = password.slice(j - 1, +j + 1 || 9e9);
      if (password.charAt(j - 1) === password.charAt(j)) {
        j += 1;
      } else {
        if (j - i > 2) { // don't consider length 1 or 2 chains.
          result.push({
            pattern: 'repeat',
            i: i,
            j: j - 1,
            token: password.slice(i, j),
            repeated_char: password.charAt(i)
          });
        }
        break;
      }
    }
    i = j;
  }
  return result;
};

SEQUENCES = {
  lower: 'abcdefghijklmnopqrstuvwxyz',
  upper: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  digits: '01234567890'
};

sequence_match = function(password) {
  var chr, cur_char, cur_n, direction, i, i_n, j, j_n, prev_char, prev_n, result, seq, seq_candidate, seq_candidate_name, seq_direction, seq_name;
  result = [];
  i = 0;
  while (i < password.length) {
    j = i + 1;
    seq = null; // either lower, upper, or digits
    seq_name = null;
    seq_direction = null; // 1 for ascending seq abcd, -1 for dcba
    for (seq_candidate_name in SEQUENCES) {
      seq_candidate = SEQUENCES[seq_candidate_name];
      [i_n, j_n] = (function() {
        var l, len1, ref, results;
        ref = [password.charAt(i), password.charAt(j)];
        results = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          chr = ref[l];
          results.push(seq_candidate.indexOf(chr));
        }
        return results;
      })();
      if (i_n > -1 && j_n > -1) {
        direction = j_n - i_n;
        if (direction === 1 || direction === (-1)) {
          seq = seq_candidate;
          seq_name = seq_candidate_name;
          seq_direction = direction;
          break;
        }
      }
    }
    if (seq) {
      while (true) {
        [prev_char, cur_char] = password.slice(j - 1, +j + 1 || 9e9);
        [prev_n, cur_n] = (function() {
          var l, len1, ref, results;
          ref = [prev_char, cur_char];
          results = [];
          for (l = 0, len1 = ref.length; l < len1; l++) {
            chr = ref[l];
            results.push(seq_candidate.indexOf(chr));
          }
          return results;
        })();
        if (!!cur_n && (cur_n - prev_n === seq_direction)) {
          j += 1;
        } else {
          if (j - i > 2) { // don't consider length 1 or 2 chains.
            result.push({
              pattern: 'sequence',
              i: i,
              j: j - 1,
              token: password.slice(i, j),
              sequence_name: seq_name,
              sequence_space: seq.length,
              ascending: seq_direction === 1
            });
          }
          break;
        }
      }
    }
    i = j;
  }
  return result;
};

//-------------------------------------------------------------------------------
// digits, years, dates ---------------------------------------------------------
//-------------------------------------------------------------------------------
repeat = function(chr, n) {
  var i;
  return ((function() {
    var l, ref, results;
    results = [];
    for (i = l = 1, ref = n; (1 <= ref ? l <= ref : l >= ref); i = 1 <= ref ? ++l : --l) {
      results.push(chr);
    }
    return results;
  })()).join('');
};

findall = function(password, rx) {
  var match, matches;
  matches = [];
  while (true) {
    match = password.match(rx);
    if (!match) {
      break;
    }
    match.i = match.index;
    match.j = match.index + match[0].length - 1;
    matches.push(match);
    password = password.replace(match[0], repeat(' ', match[0].length));
  }
  return matches;
};

digits_rx = /\d{3,}/;

digits_match = function(password) {
  var i, j, l, len1, match, ref, results;
  ref = findall(password, digits_rx);
  results = [];
  for (l = 0, len1 = ref.length; l < len1; l++) {
    match = ref[l];
    [i, j] = [match.i, match.j];
    results.push({
      pattern: 'digits',
      i: i,
      j: j,
      token: password.slice(i, +j + 1 || 9e9)
    });
  }
  return results;
};

// 4-digit years only. 2-digit years have the same entropy as 2-digit brute force.
year_rx = /19\d\d|200\d|201\d/;

year_match = function(password) {
  var i, j, l, len1, match, ref, results;
  ref = findall(password, year_rx);
  results = [];
  for (l = 0, len1 = ref.length; l < len1; l++) {
    match = ref[l];
    [i, j] = [match.i, match.j];
    results.push({
      pattern: 'year',
      i: i,
      j: j,
      token: password.slice(i, +j + 1 || 9e9)
    });
  }
  return results;
};

date_match = function(password) {
  // match dates with separators 1/1/1911 and dates without 111997
  return date_without_sep_match(password).concat(date_sep_match(password));
};

date_without_sep_match = function(password) {
  var candidate, candidates_round_1, candidates_round_2, date_matches, day, digit_match, end, i, j, l, len1, len2, len3, m, month, o, ref, token, valid, year;
  date_matches = [];
  ref = findall(password, /\d{4,8}/);
  // 1197 is length-4, 01011997 is length 8
  for (l = 0, len1 = ref.length; l < len1; l++) {
    digit_match = ref[l];
    [i, j] = [digit_match.i, digit_match.j];
    token = password.slice(i, +j + 1 || 9e9);
    end = token.length;
    candidates_round_1 = []; // parse year alternatives
    if (token.length <= 6) {
      candidates_round_1.push({ // 2-digit year prefix
        daymonth: token.slice(2),
        year: token.slice(0, 2),
        i: i,
        j: j
      });
      candidates_round_1.push({ // 2-digit year suffix
        daymonth: token.slice(0, end - 2),
        year: token.slice(end - 2),
        i: i,
        j: j
      });
    }
    if (token.length >= 6) {
      candidates_round_1.push({ // 4-digit year prefix
        daymonth: token.slice(4),
        year: token.slice(0, 4),
        i: i,
        j: j
      });
      candidates_round_1.push({ // 4-digit year suffix
        daymonth: token.slice(0, end - 4),
        year: token.slice(end - 4),
        i: i,
        j: j
      });
    }
    candidates_round_2 = []; // parse day/month alternatives
    for (m = 0, len2 = candidates_round_1.length; m < len2; m++) {
      candidate = candidates_round_1[m];
      switch (candidate.daymonth.length) {
        case 2: // ex. 1 1 97
          candidates_round_2.push({
            day: candidate.daymonth[0],
            month: candidate.daymonth[1],
            year: candidate.year,
            i: candidate.i,
            j: candidate.j
          });
          break;
        case 3: // ex. 11 1 97 or 1 11 97
          candidates_round_2.push({
            day: candidate.daymonth.slice(0, 2),
            month: candidate.daymonth[2],
            year: candidate.year,
            i: candidate.i,
            j: candidate.j
          });
          candidates_round_2.push({
            day: candidate.daymonth[0],
            month: candidate.daymonth.slice(1, 3),
            year: candidate.year,
            i: candidate.i,
            j: candidate.j
          });
          break;
        case 4: // ex. 11 11 97
          candidates_round_2.push({
            day: candidate.daymonth.slice(0, 2),
            month: candidate.daymonth.slice(2, 4),
            year: candidate.year,
            i: candidate.i,
            j: candidate.j
          });
      }
    }
// final loop: reject invalid dates
    for (o = 0, len3 = candidates_round_2.length; o < len3; o++) {
      candidate = candidates_round_2[o];
      day = parseInt(candidate.day);
      month = parseInt(candidate.month);
      year = parseInt(candidate.year);
      [valid, [day, month, year]] = check_date(day, month, year);
      if (!valid) {
        continue;
      }
      date_matches.push({
        pattern: 'date',
        i: candidate.i,
        j: candidate.j,
        token: password.slice(i, +j + 1 || 9e9),
        separator: '',
        day: day,
        month: month,
        year: year
      });
    }
  }
  return date_matches;
};

date_rx_year_suffix = /(\d{1,2})(\s|-|\/|\\|_|\.)(\d{1,2})\2(19\d{2}|200\d|201\d|\d{2})/; // day or month
// separator
// month or day
// same separator
// year

date_rx_year_prefix = /(19\d{2}|200\d|201\d|\d{2})(\s|-|\/|\\|_|\.)(\d{1,2})\2(\d{1,2})/; // year
// separator
// day or month
// same separator
// month or day

date_sep_match = function(password) {
  var day, k, l, len1, len2, len3, m, match, matches, month, o, ref, ref1, results, valid, year;
  matches = [];
  ref = findall(password, date_rx_year_suffix);
  for (l = 0, len1 = ref.length; l < len1; l++) {
    match = ref[l];
    [match.day, match.month, match.year] = (function() {
      var len2, m, ref1, results;
      ref1 = [1, 3, 4];
      results = [];
      for (m = 0, len2 = ref1.length; m < len2; m++) {
        k = ref1[m];
        results.push(parseInt(match[k]));
      }
      return results;
    })();
    match.sep = match[2];
    matches.push(match);
  }
  ref1 = findall(password, date_rx_year_prefix);
  for (m = 0, len2 = ref1.length; m < len2; m++) {
    match = ref1[m];
    [match.day, match.month, match.year] = (function() {
      var len3, o, ref2, results;
      ref2 = [4, 3, 1];
      results = [];
      for (o = 0, len3 = ref2.length; o < len3; o++) {
        k = ref2[o];
        results.push(parseInt(match[k]));
      }
      return results;
    })();
    match.sep = match[2];
    matches.push(match);
  }
  results = [];
  for (o = 0, len3 = matches.length; o < len3; o++) {
    match = matches[o];
    [valid, [day, month, year]] = check_date(match.day, match.month, match.year);
    if (!valid) {
      continue;
    }
    results.push({
      pattern: 'date',
      i: match.i,
      j: match.j,
      token: password.slice(match.i, +match.j + 1 || 9e9),
      separator: match.sep,
      day: day,
      month: month,
      year: year
    });
  }
  return results;
};

check_date = function(day, month, year) {
  if ((12 <= month && month <= 31) && day <= 12) { // tolerate both day-month and month-day order
    [day, month] = [month, day];
  }
  if (day > 31 || month > 12) {
    return [false, []];
  }
  if (!((1900 <= year && year <= 2019))) {
    return [false, []];
  }
  return [true, [day, month, year]];
};
